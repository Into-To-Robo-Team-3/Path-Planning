
#pragma config(Motor,  motorA,          leftMotor,    tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightMotor,     tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define POWER 50
int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

int motorPower = POWER;
// Controls
int target = 0;
float kp = 5;
float ki = 250;
float kd = 4;
//float kf = 1;
int totalError = 0;
//float multiplier = 1; // motor power difference compensator

//Robot Attributes
float od=2.25;     //Wheel diameter
//float dwb=4.25; //wheel base diameter
float cir=od*PI; //Wheel goalStraightumference
float ticksperin=360/cir;  //ticks per inch



int control(int input, float damp, float integral){ //control portion of diagram, formula we're using is kp*angle+kd*angularVelocity
	int output = (int)((int)(kp*(float)input-damp+integral));
	return output;
}
int plant(int power, int input){ //plant section of diagram
	int leftOffset = 0;
	int rightOffset = 0;
	if(input < motorPower) //left motor slacking
		leftOffset = -input;
	else if(input > motorPower) //right motor slacking
		rightOffset = -input;
	motor[leftMotor] = power + leftOffset;
	motor[rightMotor] = power + rightOffset;
	int result = nMotorEncoder(leftMotor) - nMotorEncoder(rightMotor);
	//nxtDisplayString(5,"L_power: %d", power + leftOffset);
	//nxtDisplayString(6,"R_power: %d", power + rightOffset);
	return result;
}


void straight(float input) //input = distance in inches
{
	//reset encoders
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	//set up motor PID
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

  float ticks=input*ticksperin; //total ticks
  float ramp_slope = 0.001; //acceleration rate
  float ramp = 0; //start from standstill
  float scale = 1.01; //travel distance compensator
  int pastError = 0;
  int currentError = 0;
  int output = 0; //for plant()
  int power = 0; //power to be assigned to motor
  //loop through encoder ticks
  while(nMotorEncoder(leftMotor)+nMotorEncoder(rightMotor) <(int)(2*ticks*scale)){
  	if(ramp < 1) //accelerate
   			ramp = ramp + ramp_slope;
   	power = motorPower*ramp;
   	pastError = currentError;
 		currentError = nMotorEncoder(leftMotor) - nMotorEncoder(rightMotor);
 		totalError = totalError + currentError; //for integral term
 		float damp = kd*(float)(currentError - pastError); //damper
 		float integral = (float)totalError/ki; //integral
 		int c = control(output - target,damp,integral);
		//nxtDisplayString(0,"Input: %d",c);
		//nxtDisplayString(1,"Output:%d", output);
		//nxtDisplayString(2,"Error: %d", currentError);
		output = plant(power, c);
 	}
 	//stop
 	motor[leftMotor]=0;
  motor[rightMotor]=0;
  //reset encoders
  nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
  //nxtDisplayString(3,"L_Motor: %d", nMotorEncoder[leftMotor]);
  //nxtDisplayString(4,"R_Motor: %d", nMotorEncoder[rightMotor]);
  //nxtDisplayString(5,"totalError: %d", totalError);
  return;
}

void turn(int goalTurn){
	//nxtDisplayString(7,"YEERRRR");
	float turn_pwr=30;
	float od=2.25;     //Wheel diameter
	float turnAng=(float)goalTurn; //angle to turn
	float dwb=4.25; //wheel base diameter
	float wheelAng=((dwb*turnAng)/od);//Angle we want the wheel to turn
	float t_ramp_slope = 0.0001;
  float turn_ramp = 0;
  float turn_scale= 0.945;
  //Turn left (positive) or right (negative)
	while(nMotorEncoder(leftMotor) < (int)(wheelAng*turn_scale)||(wheelAng<0&&nMotorEncoder(leftMotor)>(int)(wheelAng*turn_scale))){
		//turn_ramp = 1;
		if(wheelAng>0){
			if(turn_ramp < 1) //Gradually bring the robot to turning speed to minimize slip
 				turn_ramp = turn_ramp + t_ramp_slope;
 			motor[leftMotor]=(int)(turn_pwr*turn_ramp);
 			motor[rightMotor]=-(int)(turn_pwr*turn_ramp);
 		}
 		else{//
 			if(turn_ramp < 1)
 				turn_ramp = turn_ramp + t_ramp_slope;
 			motor[leftMotor]=-(int)(turn_pwr*turn_ramp);
 			motor[rightMotor]=(int)(turn_pwr*turn_ramp);
 		}
  }
  //stop
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
  //reset encoders
  nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	return;
}

task locomotion()
{
	//int distance = 12;
	//straight(distance);
	//wait1Msec(200);
	//nxtDisplayString(7,"TUUUUURNNN");
	int x1 = 20;
	int y1 = 6;
	int x2 = 20;
	int y2 = 40;
	int length = 9;
	float directions[9][2] = {
		//{6.75, 0},
		//{8.8388, -45},
		//{8.25, 90},
		//{4.596, -45},
		{0, -90}, {36.0, 0}, {0, 45}, {35.70885300000004, 0}, {0, 135}, {24.5, 0}, {0, -45}, {0.707106, 0}, {0, -135}
		};
	for(int index = 0; index < length; index++){
		float angle = directions[index][1];
		float distance = directions[index][0];
		if(angle == 0){
			nxtDisplayString(0,"Distance: %f",distance);
			straight(distance);
		}
		else{
			nxtDisplayString(1,"Angle: %f",angle);
			turn(-angle);
		}

		//turn(angle);
		wait10Msec(100);
		//wait10Msec(100);
	}
}

task main()
{
	startTask(locomotion);
	while(nNxtButtonPressed != kExitButton) {}
}
